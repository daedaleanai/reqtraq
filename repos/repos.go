/*
	Manages multiple repositories, registering them and allowing the user to lookup files within them

	The base repository is the one where reqtraq was originally invoked. This is registered with
	SetBaseRepoInfo and must be done before any of the other methods are called
*/

package repos

import (
	"fmt"
	"io/fs"
	"io/ioutil"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/daedaleanai/reqtraq/linepipes"
)

// A reference to a remote repository that can be one of:
//   - An HTTP url referencing a remote git repository
//   - A ssh url referencing a remote git repository
//   - A git url referencing a remote git repository
//   - A local repository that will be cloned
// TODO(ja): Allow the user to specify a custom branch/git ref in this path
type RemotePath string

// Identifies a single repository
type RepoName string

// A path to a local repository that is present in the current filesystem
type RepoPath string

var (
	// Set to true if the base repository information has been set
	baseRepoInfoSet bool = false
	// The path to the base repository
	basePath RepoPath = ""
	// The name of the base repository
	baseName RepoName = RepoName("")
	// A list of temporary directories generated by
	tempDirs []string = make([]string, 0)
	// Maps from name to path
	repositories map[RepoName]RepoPath = make(map[RepoName]RepoPath)
)

// Collects the information about the base repository (the repository where the reqtraq command is run)
// @llr REQ-TRAQ-SWL-49
func SetBaseRepoInfo(repoPath RepoPath, repoName RepoName) {
	if baseRepoInfoSet {
		panic("Attempted to set base repository information twice")
	}
	baseRepoInfoSet = true

	basePath = repoPath
	baseName = repoName
}

// Returns the local path to the base repository. Requires that SetBaseRepoInfo has been called before.
// @llr REQ-TRAQ-SWL-49
func BaseRepoPath() RepoPath {
	if !baseRepoInfoSet {
		panic("Base repo information is not set!")
	}
	return basePath
}

// Returns the name to the base repository. Requires that SetBaseRepoInfo has been called before.
// @llr REQ-TRAQ-SWL-49
func BaseRepoName() RepoName {
	if !baseRepoInfoSet {
		panic("Base repo information is not set!")
	}
	return baseName
}

// Registers a repository in the registry, that can be queried using the repository name.
// @llr REQ-TRAQ-SWL-49
func RegisterRepository(name RepoName, path RepoPath) {
	repositories[name] = path
}

// Unregisters all repositories from the registry, leaving it empty
// @llr REQ-TRAQ-SWL-49
func ClearAllRepositories() {
	repositories = make(map[RepoName]RepoPath)
}

// Gets the local path to a repository by name. The remotePath will be used to create a local
// repository copy if the repository is not registered or the override flag is set.
// @llr REQ-TRAQ-SWL-49, REQ-TRAQ-SWL-50
func GetRepo(repoName RepoName, remotePath RemotePath, gitReference string, override bool) (RepoPath, error) {
	if !override {
		// Check if it is already registered, if so just return it
		repoPath, err := GetRepoPathByName(repoName)
		if err == nil {
			return repoPath, nil
		}
	}

	// Clone the repo
	path, err := cloneFromRemote(repoName, remotePath, gitReference)
	if err != nil {
		return "", err
	}

	// Now let's store it
	repositories[repoName] = path
	return path, nil
}

// Obtains the local path to a repository from its name, if the repository is registered
// @llr REQ-TRAQ-SWL-49
func GetRepoPathByName(name RepoName) (RepoPath, error) {
	if path, ok := repositories[name]; ok {
		return path, nil
	}
	return "", fmt.Errorf("Could not find path for repository with name `%s`", name)
}

// Creates a local copy of the given remote repository in a temporary folder and registers it for
// deletion when CleanupTemporaryDirectories is called.
// @llr REQ-TRAQ-SWL-49, REQ-TRAQ-SWL-16
func cloneFromRemote(repoName RepoName, remotePath RemotePath, gitReference string) (RepoPath, error) {
	cloneDir, err := ioutil.TempDir("", ".reqtraq")
	if err != nil {
		return "", err
	}

	repoPath := RepoPath(filepath.Join(cloneDir, string(repoName)))

	// Use the baseRepoPath when checking out repositories in case remotePath is a local path
	originalDir, err := os.Getwd()
	if err != nil {
		return "", err
	}
	err = os.Chdir(string(basePath))
	if err != nil {
		return "", err
	}
	defer os.Chdir(originalDir)

	if _, err := linepipes.All(linepipes.Run("git", "clone", string(remotePath), string(repoPath))); err != nil {
		return "", err
	}

	if gitReference != "" {
		if _, err := linepipes.All(linepipes.Run("git", "-C", string(repoPath), "checkout", gitReference)); err != nil {
			return "", err
		}
	}

	// Save the  temp dir for cleanup when we exit
	tempDirs = append(tempDirs, string(repoPath))
	return repoPath, nil
}

// Removes any temporary directories where repositories have been cloned
// @llr REQ-TRAQ-SWL-49
func CleanupTemporaryDirectories() {
	for _, dir := range tempDirs {
		os.RemoveAll(dir)
	}
}

// Finds files in the given repository, returning an array of paths to each matched file
// Its arguments are:
// - `repoName`: Repo where files are located
// - `path`: The path to look in. Only files in this path (relative to the root of the repo) will be matched.
// - `pattern` The pattern to match against. If the pattern matches, it is added to the result array.
// - `ignoredPaths`: Any ignored path regexp. If the file matches any regular expression in this array it will not be matched
// @llr REQ-TRAQ-SWL-49, REQ-TRAQ-SWL-51
func FindFilesInDirectory(repoName RepoName, path string, pattern *regexp.Regexp, ignoredPaths []*regexp.Regexp) ([]string, error) {
	var files []string

	repoPath, err := GetRepoPathByName(repoName)
	if err != nil {
		return []string{}, err
	}
	actualPath := filepath.Join(string(repoPath), path)

	err = filepath.Walk(actualPath, func(path string, fileInfo fs.FileInfo, err error) error {
		// First lets start by removing the prefix from the actualPath
		relativePath, err := filepath.Rel(string(repoPath), path)
		if err != nil {
			return fmt.Errorf(`Error while walking a path and removing the prefix.
This should not happen. Please inform the developers by rasing an issue if you see this.`)
		}

		// Match path against ignoredPaths. If it does match, return skipdir
		for _, ignoredPath := range ignoredPaths {
			if ignoredPath.MatchString(relativePath) {
				return nil
			}
		}

		if fileInfo == nil || fileInfo.IsDir() {
			// We do not add directories to the list
			return nil
		}

		// Match path against pattern. If it does not match, continue
		if pattern != nil {
			if !pattern.MatchString(relativePath) {
				// Does not match pattern, filter it out
				return nil
			}
		}

		// For everything else, append it
		files = append(files, relativePath)

		return nil
	})

	if err != nil {
		return []string{}, err
	}

	return files, nil
}

// Returns an absolute path to a file inside a repository. It validates that the file exists.
// If it doesn't an error is returned.
// @llr REQ-TRAQ-SWL-49, REQ-TRAQ-SWL-51
func PathInRepo(repoName RepoName, path string) (string, error) {
	repoPath, err := GetRepoPathByName(repoName)
	if err != nil {
		return "", err
	}

	actualPath := filepath.Join(string(repoPath), path)
	if _, err := os.Stat(actualPath); err != nil {
		return "", fmt.Errorf("Path `%s` does not seem to be accessible from the user: %s", actualPath, err)
	}

	return actualPath, nil
}

var emptyLineMatcher = regexp.MustCompile("^\\s*$")

// AllCommits returns the list of commits formatted as "ID DATE".
// @llr REQ-TRAQ-SWL-16
func AllCommits(repoName RepoName) ([]string, error) {
	repoPath, err := GetRepoPathByName(repoName)
	if err != nil {
		return []string{}, err
	}

	commits := make([]string, 0)
	lines, err := linepipes.All(linepipes.Run("git", "-C", string(repoPath), "log", `--pretty=format:%h %cd`, "--date=short"))
	if err != nil {
		return commits, fmt.Errorf("Failed to get the list of commits: %s", err)
	}

	for _, line := range strings.Split(lines, "\n") {
		if !emptyLineMatcher.MatchString(line) {
			commits = append(commits, line)
		}
	}

	return commits, nil
}
