package repos

import (
	"fmt"
	"io/fs"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/daedaleanai/reqtraq/linepipes"
)

// A reference to a remote repository that can be one of:
//   - An HTTP url referencing a remote git repository
//   - A ssh url referencing a remote git repository
//   - A git url referencing a remote git repository
//   - A local repository that will be cloned
// TODO(ja): Allow the user to specify a custom branch/git ref in this path
type RemotePath string

// Identifies a single repository
type RepoName string

// A path to a local repository that is present in the current filesystem
type RepoPath string

var (
	// The path to the base repository
	basePath string = ""
	// The name of the base repository
	baseName RepoName = RepoName("")
	// A list of temporary directories generated by
	tempDirs []string = make([]string, 0)
	// Maps from name to path
	repositories map[RepoName]RepoPath = make(map[RepoName]RepoPath)
)

// Names from remote paths are assumed to be of either of these forms:
func GetRepoNameFromPath(path string) RepoName {
	name := filepath.Base(path)

	// If name ends with ".git" strip it, as that is part of the git URL
	name = strings.TrimSuffix(name, ".git")
	return RepoName(name)
}

func loadBaseRepoInfo() {
	// See details about "working directory" in https://git-scm.com/docs/githooks
	bare, err := linepipes.Single(linepipes.Run("git", "rev-parse", "--is-bare-repository"))
	if err != nil {
		log.Fatal("Failed to check Git repository type. Are you running reqtraq in a Git repo?\n", err)
	}
	if bare == "true" {
		log.Fatal("Bare repository.")
	}

	toplevel, err := linepipes.Single(linepipes.Run("git", "rev-parse", "--show-toplevel"))
	if err != nil {
		log.Fatal(err)
	}

	basePath = toplevel
	baseName = GetRepoNameFromPath(toplevel)
}

func BaseRepoPath() string {
	if basePath == "" {
		loadBaseRepoInfo()
	}

	return basePath
}

func BaseRepoName() RepoName {
	if baseName == "" {
		loadBaseRepoInfo()
	}

	return baseName
}

func RegisterRepository(path string) RepoName {
	// Name is deduced from path
	name := GetRepoNameFromPath(path)
	repositories[name] = RepoPath(path)

	return name
}

func ClearAllRepositories() {
	repositories = make(map[RepoName]RepoPath)
}

// If it is already registered, it just returns the key and path as stored internally, unless you set
// the override flag
func GetRepo(remotePath RemotePath, gitReference string, override bool) (RepoName, RepoPath, error) {
	// Deduce the name out of the repository
	name := GetRepoNameFromPath(string(remotePath))

	if !override {
		// Check if it is already registered, if so just return it
		repoPath, err := GetRepoPathByName(name)
		if err == nil {
			return name, repoPath, nil
		}
	}

	// Clone the repo
	path, err := cloneFromRemote(remotePath, gitReference)
	if err != nil {
		return "", "", err
	}

	// Now let's store it
	repositories[name] = path
	return name, path, nil
}

// Obtains the path of a repository from its name
func GetRepoPathByName(name RepoName) (RepoPath, error) {
	if path, ok := repositories[name]; ok {
		return path, nil
	}
	return "", fmt.Errorf("Could not find path for repository with name `%s`", name)
}

/// Obtains a RepoPath from a RemotePath by cloning the repository locally
func cloneFromRemote(remotePath RemotePath, gitReference string) (RepoPath, error) {
	cloneDir, err := ioutil.TempDir("", ".reqtraq")
	if err != nil {
		return "", err
	}

	repoPath := RepoPath(filepath.Join(cloneDir, string(GetRepoNameFromPath(string(remotePath)))))

	if _, err := linepipes.All(linepipes.Run("git", "clone", string(remotePath), string(repoPath))); err != nil {
		return "", err
	}

	if gitReference != "" {
		if _, err := linepipes.All(linepipes.Run("git", "-C", string(repoPath), "checkout", gitReference)); err != nil {
			return "", err
		}
	}

	// Save the  temp dir for cleanup when we exit
	tempDirs = append(tempDirs, string(repoPath))
	return repoPath, nil
}

func CleanupTemporaryDirectories() {
	for _, dir := range tempDirs {
		os.RemoveAll(dir)
	}
}

// 1. Repo where files are located
// 2. The path to look in
// 3. pattern to match against
// 4. Ignored paths
func FindFilesInDirectory(repoName RepoName, path string, pattern *regexp.Regexp, ignoredPaths []*regexp.Regexp) ([]string, error) {
	var files []string

	repoPath, err := GetRepoPathByName(repoName)
	if err != nil {
		return []string{}, err
	}
	actualPath := filepath.Join(string(repoPath), path)

	err = filepath.Walk(actualPath, func(path string, fileInfo fs.FileInfo, err error) error {
		// First lets start by removing the prefix from the actualPath
		relativePath, err := filepath.Rel(string(repoPath), path)
		if err != nil {
			return fmt.Errorf(`Error while walking a path and removing the prefix.
This should not happen. Please inform the developers by rasing an issue if you see this.`)
		}

		// Match path against ignoredPaths. If it does match, return skipdir
		for _, ignoredPath := range ignoredPaths {
			if ignoredPath.MatchString(relativePath) {
				return nil
			}
		}

		if fileInfo == nil || fileInfo.IsDir() {
			// We do not add directories to the list
			return nil
		}

		// Match path against pattern. If it does not match, continue
		if pattern != nil {
			if !pattern.MatchString(relativePath) {
				// Does not match pattern, filter it out
				return nil
			}
		}

		// For everything else, append it
		files = append(files, relativePath)

		return nil
	})

	if err != nil {
		return []string{}, err
	}

	return files, nil
}

func PathInRepo(repoName RepoName, path string) (string, error) {
	repoPath, err := GetRepoPathByName(repoName)
	if err != nil {
		return "", err
	}

	actualPath := fmt.Sprintf("%s/%s", repoPath, path)
	if err != nil {
		return "", err
	}

	if _, err := os.Stat(actualPath); err != nil {
		return "", fmt.Errorf("Path `%s` does not seem to be accessible from the user: %s", actualPath, err)
	}

	return actualPath, nil
}

var emptyLineMatcher = regexp.MustCompile("^\\s*$")

// AllCommits returns the list of commits formatted as "ID DATE".
// @llr REQ-TRAQ-SWL-16
func AllCommits(repoName RepoName) ([]string, error) {
	repoPath, err := GetRepoPathByName(repoName)
	if err != nil {
		return []string{}, err
	}

	commits := make([]string, 0)
	lines, err := linepipes.All(linepipes.Run("git", "-C", string(repoPath), "log", `--pretty=format:%h %cd`, "--date=short"))
	if err != nil {
		return commits, fmt.Errorf("Failed to get the list of commits: %s", err)
	}

	for _, line := range strings.Split(lines, "\n") {
		if !emptyLineMatcher.MatchString(line) {
			commits = append(commits, line)
		}
	}

	return commits, nil
}
